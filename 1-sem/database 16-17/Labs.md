# Лабораторная работа №1. Запрос па основе одной таблицы.
На основе одной таблицы можно реализовать одну из двух операций реляционной алгебры: проекцию и выборку.

**Проекция** (вертикальное подмножество) таблицы создается из указанных ее столбцов (в заданном порядке) с возможным последующим исключением избыточных дубликатов строк. Пример:

Синтаксис предложения Select:
```SQL
SELECT
    Список столбцов или «*», если нужно выбрать все столбцы
FROM
    Название таблицы
```

*Пример 1*
```SQL
SELECT
    Name, Color
FROM
    Production.Product
```

Часто возникает ситуация, когда в результате проекции получается ряд одинаковых строк, так как отличия находились в строках, нс выбранных нами для проекции. Для исключения такой избыточности перед именованием необходимых столбцов используется ключевое слово DISTINCT

*Пример 2*
```SQL
SELECT
    DISTINCT Color
FROM
    Production.Product
```

Непосредственно в предложении Select можно производить вычисления (арифметические операции над значениями ячеек и константами).

*Пример 3*
```SQL
SELECT
    Name, StandardCost, ListPrice, (ListPrice - StandardCost)
FROM
    Production.Product
```

**Выборка** (горизонтальное подмножество) таблицы создается из тех ее строк, которые удовлетворяют заданным условиям.

Синтаксис предложения Select:
```SQL
SELECT
    Список столбцов или «*», если нужно выбрать все столбцы
FROM
    Название таблицы
WHERE
    Условия
```

В условии можно использовать операторы сравнения «=», «<>», «<», «<=», «>», «>=» , а также логические операции AND, OR и NOT.

*Пример 4*
```SQL
SELECT
    Name, Color
FROM
    Production.Product
WHERE
    Color = 'Black'
```

*Пример 5*
```SQL
SELECT
    Name, StandardCost, ListPrice, (ListPrice - StandardCost)
FROM
    Production.Product
WHERE
    (ListPrice - StandardCost) >= 100
```

*Пример 6*
```SQL
SELECT
    Name, ProductLine, Style
FROM
    Production.Product
WHERE
    ProductLine = 'R'
    AND Style = 'W'
```

При необходимости указания в условии диапазонов возможных значений можно использовать ключевые слова:
```SQL
IN (перечисление возможных значений);
BETWEEN начальное значение диапазона AND конечное значение диапазона.
```

*Пример 7*
```SQL
SELECT
    Name, Color
FROM
    Production.Product
WHERE
    Color in ('Black', 'Red')
```

*Пример 8*
```SQL
SELECT
    Name, Weight
FROM
    Production.Product
WHERE
    Weight BETWEEN 10 AND 20
```

Для столбцов текстового типа есть возможность использовать ключевое слово **LIKE**, обеспечивающее сравнение с маской в которой символ «_» обозначает единичный символ, а символ «%» - любое количество (в том числе нулевое) любых символов.

*Пример 9*
```SQL
SELECT
    Name
FROM
    Production.Product
WHERE
    Name LIKE '%Lock%'
```

## Задание лабораторной работы №1
1.	Ознакомиться со структурой таблиц Production.Produet, Person.Contact, I IumanRcsources.Employee и Purchasing. Vendor
(http://msdn.microsort.com/ru-ru/library/msl24438.aspx)
2.	Выполнить запросы, приведенные в примерах и дать их содержательную интерпретацию
3.	Составить и выполнить следующие запросы (каждый запрос составить в отдельной вкладке):
    1.	Получить список (названия компаний) всех активно использующихся поставщиков запчастей и других товаров
    2.	Получить список всех поставщиков запчастей и других товаров с кредитным рейтингом от среднего до отличного включительно (названия компаний и кредитный рейтинг)
    3.	Получить список всех поставщиков запчастей и других товаров, для которых в БД хранятся данные об их Интернет-ресурсе (названия компаний и адрес Интернет-ресурса)
    4.	Получить список всех женских имен (без повторений) из таблицы контактной информации
    5.	Получить полное имя (включая принятое обращение) и адреса электронной почты тех лиц, которые согласились получать рекламную рассылку
    6.	Получить полное имя (включая принятое обращение) и номера телефонов тех лиц, у которых номер телефона содержит последовательность цифр «016»
    7.	Получить список всех должностей сотрудников
    8.	Получить список должностей сотрудников, занимаемых мужчинами	,
    9.	Определить должности сотрудников, принятых на работу 4 января 2000 года
    10.	Получить перечень должностей сотрудников, принятых на работу в период с марта 1999 года по январь 2000 года включительно
    11.	Получить перечень идентификационных номеров сотрудников (ИНН) у которых суммарный отпуск (в том числе по болезни) составил более 100 часов
    12.	Получить список всех продаваемых продуктов (название), имеющих размер 40 сантиметров
    13.	Получить перечень продуктов (название), используемых во всех линейках велосипедов кроме туристических
    14.	Получить перечень всех продуктов (название), изготовленных в компании, изготовление которых требует более 3 дней
    15.	Вывести пеповторяющийся список размеров продуктов, закупленных у сторонних изготовителей


# Лабораторная работа №2. Запрос на основе одной таблицы с упорядочением и агрегированием данных
На основе одной таблицы можно реализовать выборку с упорядочением:
Простейший вариант - упорядочение строк результата по значению одного или нескольких столбцов с указанием порядка сортировки или без такого указания (в порядке возрастания ASC (ASCending) или убывания DESC (DESCending), по умолчанию принимается ASC).

Синтаксис предложения Select:
```SQL
SELECT
    Список столбцов или «*», если нужно выбрать все столбцы
FROM
    Название таблицы
WHERE
    Условия
ORDER BY
    Столбец (или их перечисление), но которым будет производится упорядочение
```
*Пример 1*
```SQL
SELECT
    Name, StandardCost, ListPrice
FROM
    Production.Product
ORDER BY
    StandardCost
```
*Пример 2*
```SQL
SELECT
    Name, Weight
FROM
    Production.Product
WHERE
    Weight BETWEEN 10 AND 20
ORDER BY
    Weight DESC
```

При включении в список ORDER BY нескольких столбцов сортируются строки результата по значениям первого столбца списка, пока не появится несколько строк с одинаковыми значениями данных в этом столбце. Такие строки сортируются по значениям следующего столбца из списка ORDER BY, и т.д.
*Пример 3*
```SQL
SELECT
    Name, StandardCost, ListPrice, (ListPrice - StandardCost)
FROM
    Production.Product
WHERE
    (ListPrice - StandardCost) >= 100
ORDER BY
    Name, ListPrice
```

Кроме того, в список ORDER BY можно включать не только имя столбца, но и порядковую позицию в перечне SELECT. Благодаря этому возможно упорядочение результатов на основе вычисляемых столбцов, не имеющих имен.
*Пример 4*
```SQL
SELECT
    Name, StandardCost, ListPrice, (ListPrice - StandardCost)
FROM
    Production.Product
ORDER BY
    4
```

**Агрегирование** - объединение нескольких элементов в единое целое путем вычисления значений с помощью агрегирующих функций.
Синтаксис предложения Select:
```SQL
SELECT
    Список столбцов и/или функций от столбцов
FROM
    Название таблицы
WHERE
    Условия
GROUP BY
    Группировка по указанному перечню столбцов с получением для каждой группы единственного значения
HAVING
    Условия исключения групп
```

В списке столбцов выражения SELECT можно использовать функции, возвращающие единственное значение, полученное в результате обработки значений в столбце: SUM (сумма), COUNT (количество записей), MIN (минимальное значение), МАХ (максимальное значение), AVG (среднее значение). Тип аргумента функций SUM и AVG должен быть числовым.
*Пример 5*
```SQL
SELECT
    MIN(ListPrice)
FROM
    Production.Product
```

Так как результатом выполнения функции MIN, как и других агрегирующих функций, будет одно значение, в запросе с их использованием нельзя применять конструкции, возвращающие несколько значений (например, простую выборку значений столбцов).
Всем функциям, кроме COUNT(). может предшествовать ключевое слово DISTINCT. Для функции COUNT() допускается конструкция вида COUNT(DISTINCT I.istPrice).
Выражение GROUP BY используется в конструкциях с агрегирующими функциями для группировки результирующей выборки но одному или более столбцам.

*Пример б*
```SQL
SELECT
    Style, AVG (ListPrice)
FROM
    Production.Product
GROUP BY
    Style
```
*Пример 7*
```SQL
SELECT
    Class, Name, SUM{ListPrice - StandardCost)
FROM
    Production.Product
WHERE
    ListPrice <> 0
GROUP BY
    Class, Name
```

Фраза HAVING используется для исключения групп, включается в предложение лишь при наличии фразы GROUP BY, а выражение в HAVING должно принимать единственное значение для группы.
*Пример 8*
```SQL
SELECT
    UnitPrice, MAX(UnitPriceDiscount)
FROM
    Sales.SalesOrderDetail
GROUP BY
    UnitPrice
HAVING MAX(UnitPriceDiscount) <> 0
```
Значение NULL несравнимо ни с каким другим значением, даже со значением NULL. Тем не менее, предложение GROUP BY объединяет все NULL-значения в одну группу, DISTINCT оставляет только одно NULL-значение, а функция AVG не учитывает NULL-значения, и сумма значений поля делится на количество ненулевых значений.

## Задание к лабораторной работе № 2
1.	Ознакомиться со структурой таблиц Production.Product, Person.Contact, Hum an Resources. Employee, Purchasing.Vendor и Sales.SalesOrderDetail (http://msdn.microsoft.com/ru-ru/library/msl24438.aspx)
2.	Выполнить запросы, приведенные в примерах, и дать их содержательную интерпретацию.
3.	Составить и выполнить следующие запросы (каждый запрос составить в отдельной вкладке):
1.	Получить список продуктов (название, цена), предназначенных ддя женщин, отсортированный по цене.
2.	Полупить отсортированный список названий продуктов, закупаемых у сторонних поставщиков.
3.	Полупить упорядоченный по алфавиту список лиц (имя, фамилия, отчество), получающих рекламную рассылку.
4.	Получить список в обратном порядке названий поставщиков, имеющих отличный кредитный рейтинг.
5.	Получить список продуктов (название, цвет), изготовленных в компании, упорядоченный по цвету, за исключением товаров, для которых цвет не указан.
6.	Предоставить данные о среднем количестве дней на изготовление продуктов для каждой линейки товаров (дорожный, горный и т.д.).
7.	Указать среднюю цену закупаемых товаров.
8.	Посчитать количество активно использующихся компаний-поставщиков по каждому типу кредитного рейтинга. Указать тип рейтинга и количество поставщиков для него.
9.	Отсортировать список товаров по суммарному количеству проданных единиц (название товара, число проданных экземпляров).
10.	Получить данные о количестве сотрудников-жешцин, состоящих в браке.
11.	Определить суммарную продолжительность отпусков по болезни для женщин и для мужчин.
12.	Для каждого типа обращения к человеку посчитать число лиц его выбравших. Отсортировать список по величине получившихся групп.
13.	Указать среднее значение минимального количества складских запасов для покупного и изготовленного в компании товаров.
14.	Отсортировать производимые в компании продукты по продолжительности времени их изготовления.
15.	Указать среднюю стоимость товаров, предназначенных для мужчин и предназначенных для женщин.
16.	Для каждого типа кредитного рейтинга определить количество активно использующихся поставщиков и количество нс использующихся поставщиков.
17.	Определи ть минимальную отпускную цену за единицу продукции для каждого кода рекламной акции, за исключением рекламной акции с кодом «1» и «8». Отсортировать но коду рекламной акции.
18.	Для каждого типа обращения к женщине получить количество лиц. выбравших его.

## Лабораторная работа №3. Запрос, использующий соединение нескольких таблиц
*Декартово произведение*. Самый общий случай соединения нескольких таблиц. Результирующие строки формируются как все возможные комбинации строк всех указанных таблиц.

*Пример 1*
```SQL
SELECT
    Purchasing.Vendor.*,
    Product ion.Product.*,
    Purchasing.ProductVendor.*
FROM
    Purchasing.Vendor,
    Production.Product,
    Purchasing.ProductVendor
```

Такие запросы редко имеют практический смысл, так как в результате формируют строки семантически не связанной информации. К декартову произведению можно применить фильтрацию результирующих строк по признаку истинности отношения значений пары столбцов в разных таблицах, например, оставляя в окончательной выборке только тс строки, для которых Таблица! .СтолбецА > Таблица2. СтолбецВ. Такое соединение таблиц называется тета-соединением. В некоторых источниках отношениями для формирования тета-соединения считаются только отношения (>, <, >=, <= ). Другие источники нс накладывают ограничений на вид отношений.
В реальности, как правило, используются запросы с соединением таблиц, связанных с помощью ключевых полей. В этом случае из декартова произведения фильтруются только те строки, которые содержат одинаковые значения пар ключевых полей. Такое соединение таблиц называется эквисоединением (соединением по эквивалентности). В качестве механизма фильтрации может выступать традиционный фильтр WHERE.

*Пример 2*
```SQL
SELECT
    Purchasing.Vendor.*,
    Production.Product,
    Purchasing.ProductVendor.*
FROM
    Purchasing.Vendor,
    Production.Product,
    Purchasing.ProductVendor
WHERE
    Purchasing.Vendor.VendorID = Purchasing.ProductVendor.VendorID
    AND Production.Product.ProductID = Purchasing.ProductVendor.ProductID
```

Такого же результата можно достичь, и используя другой синаксис предложения SELECT:
*Пример 3*
```SQL
SELECT
    Purchasing.Vendor.*,
    Production.Product.*,
    Purchasing.ProductVendor.*
FROM
    (Purchasing.Vendor
        INNER JOIN Purchasing.ProductVendor
            ON Purchasing.Vendor.VendorID = Purchasing.ProductVendor.VendorlD)
INNER JOIN
    Production.Product
    ON Production.Product.ProductID = Purchasing.ProductVendor.ProductID
```

В большинстве СУБД использование именно такого синтаксиса является предпочтительным. Такой тип соединения может носить название внутреннего соединения.
На основе внутреннего соединения нескольких таблиц, также как и по одной таблице, можно осуществлять проекцию, указывая в предложении SELECT только необходимый набор столбцов
*Пример 4*
```SQL
SELECT
    Production.Product.Name,
    Purchasing.Vendor.Name,
    Purchasing.ProductVendor.LastReceiptCost
FROM
    (Purchasing.Vendor
        INNER JOIN Purchasing.ProductVendor
            ON Purchasing.Vendor.VendorID = Purchasing.ProductVendor.VendorID)
    INNER JOIN Production.Product
        ON Production.Product.ProductID = Purchasing.ProductVendor.ProductID
ORDER BY
    Production.Product.Name;
```

Поскольку результатом соединения таблиц или проекции такого соединения является виртуальная таблица, в ней можно использовать агрегирующие функции, как и в случае с единственной таблицей *Пример 5*
```SQL
SELECT
    Production.Product.Name,
    min(Purchasing.ProductVendor.LastReceiptCost)
FROM
    (Purchasing.Vendor
        INNER JOIN Purchasing.ProductVendor
            ON Purchasing.Vendor.VendorID = Purchasing.ProductVendor.VendorID)
    INNER JOIN Production.Product
        ON Production.Product.ProductID = Purchasing.ProductVendor.ProductID
GROUP BY
    Production.Product.Name
ORDER BY
    Production.Product.Name
```

Внутреннее соединение позволяет получить только строки из нескольких таблиц, имеющие связь по указанному столбцу (столбцам). Пели необходимо включить в результат запроса, кроме этой информации, все остальные строки из одной из объединяемых таблиц - используется спешнее соединение.
*Пример 6*
```SQL
SELECT
    Person.Contact.FirstName,
    Person.Contact.LastName,
    HumanResources.Employee.Title
FROM
    Person.Contact
    LEFT OUTER JOIN HumanResources.Employee
        ON Person.Contact.Contact ID=HumanResources.Employee.ContactID
```

Такой запрос выдаст значения соответствующих столбцов из всех строк первой (левой) таблицы и значения указанного столбца для тех строк из второй таблицы, для которых будет справедлива связь по ключевому полю с первой таблицей. Для тех строк, для которых нет соответствия, во второй таблице будет указано значение NULL. Этот тип соединения таблиц называется левым внешним соединением.
Если нужно вывести, наоборот, все строки из второй (правой) таблицы и только связанные с ними значения из строк первой таблицы - вместо ключевого слова LEFT используется ключевое слово RIGHT. В результате получится правое внешнее соединение таблиц.
Чтобы получить все строки как из левой, гак и из правой таблиц, связав те, у которых есть совпадение по ключевым полям, используется конструкция FULL OUTER JOIN.
Для внешних соединений, также как и для внутренних, можно использовать дополнительные условия для выборки и агрегирующие функции.
## Задание к лабораторной работе № 3
1. Ознакомиться со структурой таблиц Production.Product, Purchasing.ProductVendor, Purchasing.Vendor, Purchasing.VendorContact, Person.Conlact, HumanResources.Employee, Sales.SalesOrderHeader,
Sales.SalesOrderDetail и Sales.SpecialOfferProduct (http://msdn.microsoft.com/ru-ru/library/msl24438.aspx)
2. Ознакомиться со схемой данных БД AdventureWorks и проанализировать связи между указанными выше таблицами. Схему данных в Microsoft Visio можно скачать с microsoft.com по первой же ссылке на поисковый запрос «AdventureWorks OLTP Database Diagram»
3. Выполнить запросы, приведенные в примерах, и дать их содержательную интерпретацию.
4. Составить и выполнить следующие запросы (каждый запрос составить в отдельной вкладке):
    1.	Вывести фамилии, имена, должности и номера телефонов работников, для которых есть сведения о номере телефона.
    2.	Посчитать количество работников, для которых есть сведения об адресе электронной почты
    3.	Вывести список контактных лиц поставщиков запчастей и других товаров (Фамилия, Имя, Адрес электронной почты), отсортированный по названиям компаний-поставщиков.
    4.	Составить запрос, выводящий имена, фамилии и должности тех работников компании, которые также являются представителями компаний-поставщиков деталей и других товаров.
    5.	Получить отсортированный по алфавиту список (фамилия, имя, телефон) представителей поставщиков деталей и других товаров, использующихся в горной линейке велосипедов.
    6.	Получить список названий товаров туристической линейки. Для тех из них, которые закупаются у сторонних поставщиков, указать названия компаний-поставщиков.
    7.	Определить среднюю стандартную стоимость для классов продукции, закупаемой у сторонних поставщиков. Не учитывать товары, для которых класс не указан.
    8.	Получить перечень названий продуктов, вошедших в заказы на продажу, созданные 1 февраля 2004 года.
    9.	Получить общее количество проданных единиц каждого товара по каждому наименованию за всю историю продаж
    10.	Получить контактную информацию клиентов (имя, фамилия, телефон), чьи заказы в настоящий момент находятся в стадии выполнения.

# Лабораторная работа №4. Соединение нескольких таблиц (продолжение)
Псевдоним (псевдоимя, alias) - временная (в пределах конкретного запроса) замена основного названия столбца или таблицы. Используются два варианта синтаксиса:
```SQL
SELECT
    ИмяСтолбца AS ПсевдонимСтолбца
FROM
    Таблица

SELECT
    ИмяСтолбца ПсевдонимСтолбца
FROM
    Таблица
```

аналогично

```SQL
SELECT
    Список столбцов
FROM
    Таблица AS ПсевдонимТаблицы

SELECT
    Список столбцов
FROM
    Таблица ПсевдонимТаблицы
```

Псевдонимы можно использовать для ссылки на столбец в ORDER BY и для лучшего именования столбцов. Запрещено ссылаться на псевдоним в определении WHERE. Вызвано это тем, что при выполнении кода WHERE значение столбца может быть еще не определенным.
*Пример 1.*
```SQL
SELECT
    LastName AS Family,
    Title AS MyField
FROM
    Person.Contact
ORDER BY
    MyField
```
*Пример 2.*
```SQL
SELECT
    COUNT (LastName) SUMM,
    Title
FROM
    Person.Contact
GROUP BY
    Title
```
*Пример 3.*
```SQL
SELECT
    V.Name,
    P.Name
FROM
    Purchasing.Vendor V
    JOIN Purchasing.ProductVendor PV
        ON V.VendorID=PV.VendorID
    JOIN Production.Product P
        ON P.ProductID=PV.ProductID
```

He обязательно использовать каждый псевдоним или таблицу, которые упомянуты в предложении FROM, в предложении SELECT. Иногда, они запрашиваются исключительно потому, что могут вызываться в предикате запроса (WHERE).
*Пример 4.*
```SQL
SELECT
    b.ProductID,
    b.LocationID
FROM
    Production.Productlnventory b
    JOIN Production.Location a
        ON b.LocationID = a.LocationID
WHERE
    a.Name LIKE 'Paint%'
```

**Самообъединение** (рекурсивное соединение) — объединение таблицы с самой собой на основе операции эквисоединения. Соединения создаются в результате включения в запрос дубликата таблицы с последующим объединением между полями копий (в этом случае сравниваются значения внутри столбца одной таблицы).
*Пример 5 - поиск пар руководитель-подчиненный (в списке выбора используется текстовая константа)*
```SQL
SELECT
    Boss.EmployeelD,
    'boss for',
    Employee.EmployeelD
FROM
    HumanResources.Employee AS Boss
    JOIN HumanResources.Employee AS Employee
        ON Boss.EmployeeID=Employee.ManagerlD
ORDER BY
    Boss.ManagerlD
```
<!-- *Пример 6 - поиск всех пар заказчиков, имеющих одинаковый рейтинг*
```SQL
SELECT
    first.Name,
    second.Name,
    first.CreditRating
FROM
    Purchasing.Vendor first
    JOIN Purchasing.Vendor second
c::
furst.CreditRating = second.CreditRating
W: .RE r..'st.Name < second.Name
be- нос..одной строки значение Name в псевдониме first сначала выбирается в комбинации со знс 1ением Name в псевдониме second, а затем значение Name в псевдониме second выбирается в комбинации со значением Name в псевдониме first. Чтобы этого избежать, нужно налагать порядок на два значения, так чтобы одно было меньше другого или предшествовало ему в алфавитном порядке.
Это свойство SQL можно использовать для проверки определенных видов ошибок: -->

*Пример 7.*
```SQL
SELECT
    Cl.FirstName,
    Cl.MiddleName,
    Cl.LastName,
    Cl.EmailAddress,
    Cl.Phone,
    Cl.ContactID,
    C2.ContactID
FROM
    Person.Contact Cl
    JOIN Person.Contact C2
        ON Cl.FirstName = C2.FirstName
        AND Cl.MiddleName = C2.MiddleName
        AND Cl.LastName = C2.LastName
        AND Cl.EmailAddress = C2.EmailAddress
        AND Cl.Phone = C2.Phone
WHERE
    Cl.ContactID <> C2.ContactID
```
Для одной таблицы в запросе можно использовать любое число псевдонимов.
Можно создать соединение, которое включает и различные таблицы, и псевдонимы одной таблицы.
*Пример 8.*
```SQL
SELECT
    A.ContactID,
    В.ContactID,
    A.TerritorylD,
    Sales.SalesTerritory.CountryRegionCode
FROM
    Sales.SalesOrderHeader A
    JOIN Sales.SalesOrderHeader В
        ON A.TerritorylD = B.TerritorylD
    JOIN Sales.SalesTerritory
        ON Sales.SalesTerritory.TerritoryID = A.TerritorylD
WHERE
    A.ContactID > B.ContactID
```

UNION объединяет вывод двух или более SQL запросов в единый набор строк и столбцов. UNION отличается от соединений тем, что он не основан на декартовом произведении. Все запросы выполняются независимо друг от друга, а уже вывод их объединяется.

*Пример 9.*
```SQL
SELECT
    SalesOrderlD,
    ContactID,
    CustomerType
FROM
    Sales.SalesOrderHeader
    JOIN Sales.Customer
        ON Sales.SalesOrderHeader.CustomerID = Sales.Customer.CustomerlD
WHERE
    CustomerType='I'
UNION
SELECT
    SalesOrderlD,
    ContactID,
    CustomerType
FROM
    Sales.SalesOrderHeader
    JOIN Sales.Customer
        ON Sales.SalesOrderHeader.CustomerID = Sales.Customer.CustomerlD
WHERE CustomerType='S'
```

Требования совместимости: когда два (или более) запроса подвергаются объединению, их столбцы вывода должны быть совместимы для объединения. Это означает, что каждый запрос должен указывать одинаковое число столбцов и в том же порядке что и остальные, и тип столбцов должен быть совместимый с типами других столбцов, занимающих такую же позицию в списке выбора. Следующий запрос выполняться не будет, так как СУБД не может привести строковую константу к типу integer
*Пример 10*
```SQL
SELECT
    A.AddressID,
    'Dallas',
    A.CustomerlD
FROM
    Sales.CustomerAddress A
    JOIN Person.Address В
        ON A.AddressID = B.AddressID
WHERE B.City='Dallas'
UNION
SELECT
    C.VendorlD,
    C.AddressID,
    'Los Angeles'
FROM
    Purchasing.VendorAddress C
    JOIN Person.Address В
        ON C.AddressID = B.AddressID
WHERE B.City='Los Angeles'
```

По умолчанию UNION исключает дубликаты строк из вывода. Если хочется вывести все строки, нужно использовать ключевое слово ALL.
*Пример 11.*
```SQL
SELECT
    CustomerlD,
    CustomerType
FROM
    Sales.Customer
WHERE
    CustomerType='I'
UNION ALL
SELECT
    CustomerlD,
    CustomerType
FROM
    Sales.Customer
WHERE
    TerritoryID = l
```

Оператор UNION можно использовать в качестве разновидности оператора IF для отображения различных значений для одного поля в зависимости от значений в других нолях.
*Пример 12.*
```SQL
SELECT
    SalesOrderlD,
    '20% off',
    LineTotal,
    LineTotal* 0.80
FROM
    Sales.SalesOrderDetail
WHERE
    LineTotal < 1000
UNION
SELECT
    SalesOrderlD,
    '30% off',
    LineTotal,
    LineTotal* 0.70
FROM
    Sales.SalesOrderDetail
WHERE
    LineTotal < 10000,
UNION
SELECT
    SalesOrderlD,
    '10% off',
    LineTotal,
    LineTotal* 0.90
FROM
    Sales.SalesOrderDetail
WHERE
    LineTotal < 500
```

Использование текстовых констант в списках выбора для каждого запроса позволяет маркировать результаты в едином наборе строк по принадлежности к той или иной части результирующего запроса.

## Задание к лабораторной работе № 4
1.	Ознакомиться со структурой таблиц Production.Product, Purchasing. Product Vendor, Purchasing. Vendor, Purchasing.VendorContact, Person.Contact, HumanResources.Employee, Sales.SalesOrderHeader, Sales.SalesOrderDetail, Sales.SpecialOfferProduct, Sales. CreditCard, Sales.Salesperson,
Production.BillofMaterials, Sales.Customer, Sales.CustomerAdress, PersonAdress (http://rnsdn.microsoft.com/ru-ru/library/msl24438.aspx)
2.	Ознакомиться со схемой данных БД AdventureWorks и проанализировать связи между указанными выше таблицами. Схему данных в Microsoft Visio можно скачать с microsoft.com по первой же ссылке на поисковый запрос «AdventureWorks OLTP Database Diagram»
3.	Выполнить запросы, приведенные в примерах, и дать их содержательную интерпретацию.
4.	Составить и выполнить следующие запросы (каждый запрос составить в отдельной вкладке):
    1.	Получить идентификационный номер заказчика, а также строку адреса улицы для выставления счета и строку адреса улицы доставки товара в том случае, когда два указанных значения не совпадают
    2.	Получить пары номеров кредитных карт, принадлежащих одному и тому же заказчику (указать ContactID), исключая сочетание номера с самим собой
    3.	Получить список торговых представителей (указать идентификационные номера) с одинаковыми комиссионными, исключая повторяющиеся сочетания и сочетания с самими собой
    4.	Получить единый список идентификационных номеров компонент для сборки продукта номер 400 и изделий, для производства которых он используется, с указанием ‘Component’ или ‘Product’.
    5.	Получить перечень изделий (идентификационный номер), для производства которых требуется а) 36 - 37 и б) 38 - 40 каких-либо деталей включительно с указанием соответствующего интервала.
    6.	Посчитать количество заказов, в которых было заказано от 1 до 3 единицы и от 4 до 6 единиц любого товара включительно с указанием соответствующего интервала
    7.	Получить пары заказчиков (указать идентификационные номера), располагающихся в одном и том же городе, исключая повторяющиеся сочетания и сочетания с самим собой
    8.	Посчитать для скольких компонентов единица измерения количества кодируется символами ‘ЕА’, а для скольких ‘OZ’ (не используя WHERE)
    9.	Проверить, располагаются ли по одному и тому же адресу разные поставщики (указать идентификационные номера)
    10.	Получить идентификационные номера холостых (неженатые) сотрудников-руководителей, у которых в подчинении есть холостые (неженатые) сотрудники другого пола