# Source
Книги (взяты из 2 вопроса, могут быть полезны):  
- Проектирование, реализация и сопровождение. Теория и практика. Т.Коннолли К.Бегг [src](https://vk.com/doc32596558_475871151)
- Введение в системы баз данных. К.Дж. Дейт [src](https://drive.google.com/file/d/15-TG-5YvYYoVG1CSNzixkS8WWzZXZdLu/view?usp=sharing)
- Базы данных учебник для высших учебных заведений. А.Д. Хомоненко. [src](https://vk.com/doc94048369_441252379)

#### 1. База данных как компонент информационной системы. Определение понятия данные, функции ИС. Абстрагирование данных от методов их обработки. Многозвенная архитектура ИС.

**Данные (стандарт ISO-2382)** – это поддающееся многократной
интерпретации представление информации в формализованном виде (то есть
существуют формальные правила для описания информации), пригодным для
передачи, представления и обработки.  
**Информационная система(ИС)** – совокупность аппаратных и программных
компонент, обеспечивающие выполнение следующих пяти **функций**
относительно информации:
-   Сбор
-   Обработка
-   Хранение
-   Передача
-   Представление

**Абстрагирование данных от методов их обработки -** Я понимаю это как
то, что Дейт описывает как **независимость от данных.**

**Независимость данных** является типом [прозрачности
данных](https://ru.qwe.wiki/w/index.php?title=Data_transparency&action=edit&redlink=1),
что имеет значение для централизованной
[СУБД](https://ru.qwe.wiki/wiki/Database_management_system) . Это
относится к иммунитету пользовательских
[приложений](https://ru.qwe.wiki/wiki/Application_software) на
изменения, сделанные в определении и организации данных. Прикладные
программы не должны, в идеале, быть подвержены деталям представления и
хранения данных. СУБД обеспечивает абстрактное представление данных,
который скрывает такие детали. Пример:

у нас есть приложение запрашивающее строку от СУБД. В момент времени 1 в
СУБД эти данные записаны как строки и возвращает она строку. Если позже
скажем мы что-то поменяли в СУБД и эти данные уже записаны не как строка
а скажем как закодированные цифры т.е. 1 - красный и т.д. . То СУБД
должна все равно возвращать строку.  
**Не уверен, что это подойдет, но вроде норм:  
**Отношение в реляционной схеме Кодда поддерживает две различные формы
абстракции. Мы называем эти формы абстракции “агрегацией” и
“обобщением”. Агрегацией называется абстракция, в которой связь между
объектами рассматривается как объект более высокого уровня. При таком
абстрагировании можно игнорировать многие детали этой связи. Например,
некоторая связь между человеком, отелем и датой может быть
абстрагирована как объект “бронирование”. Можно при этом мыслить о
“бронировании”, не задумываясь о всех деталях базовой связи, например о
номере комнаты, фамилии агента по бронированию или продолжительности
бронирования.

Обобщением называется абстракция, в которой множество схожих объектов
рассматривается как некоторый родовой объект. При таком абстрагировании
можно игнорировать многие индивидуальные различия между объектами.
Например, множество людей-служащих может быть абстрагировано как родовой
объект “служащий”. В такой абстракции не учитываются индивидуальные
различия между служащими, например, те факты, что служащие имеют
различные фамилии, возраст и служебные функции.

####  

#### 2. Определения базы данных и СУБД по Конноли, Дейту и Хомоненко. Их сходства и различия. 

-   Определение баз данных:  
    > **База данных** (*Конноли и Берг)* – это совместно используемый
    > набор логически связанных данных, предназначенный для
    > удовлетворения информационных потребностей организаций.  
    > **База данных** *(Дейт)* – это набор постоянно хранимых данных,
    > используемых прикладными системами предприятия.  
    > **База данных** *(Хомоненко и Цыганков)* – это совокупность
    > специально организованных данных, хранимых в памяти вычислительной
    > системы и отображающих состояние объектов и их взаимосвязей в
    > рассматриваемой предметной области.

-   Определение СУБД:  
    > **СУБД** *(Конноли и Берг)* – программное обеспечение, с помощью
    > которого пользователи могут определять, создавать и поддерживать
    > БД, а также осуществлять к ней контроли*руемый доступ.  
    > **СУБД ***(Хомоненко и Цыганков) – комплекс языковых (могут быть
    > различные языковые диалекты) и программных средств,
    > предназначенный для создания, ведения и совместного использования
    > БД многими пользователями.  
    > **СУБД** (*Дейт*) позволяет конечному пользователю рассматривать
    > базу данных как объект более высокого уровня по сравнению с
    > аппаратным обеспечением, а также предоставляет в его распоряжение
    > набор операций, выражаемых в терминах языка высокого уровня.

-   Сходства и различия:  
    > Все эти понятия отражают суть хранения данных и доступа к ним.
    > Следовательно, БД можно рассматривать как некое структурированное
    > хранилище для информационной единицы. А СУБД, в свою очередь, лишь
    > предоставляет доступ от клиент-серверной части к самому БД.

####  

#### 3. Файловые хранилища. Недостатки. Упорядоченные и неупорядоченные файлы.

**Файл** - уникальная именованная совокупность данных, к которой можно
обращаться и работать с операциями чтения и записи  
Минусы:

-   Отсутствие семантики относительно того, что находится в файле
-   Трудно искать нужную информацию в большом файле
-   Нельзя обеспечить консистентность данных (появление неактуальности данных при чтении в случае, когда один читает, а другой в это время записывает в него информацию)
-   Можно разбить один большой файл на несколько маленьких и при чтении (записи) данный файл блокируется клиентом и доступен только ему. Проблемы будут возникать, когда двум клиентам нужно получить доступ к файлу, где сейчас работает другой клиент. Как результат, никто не может получить нужную для связи информации и происходит тупик.
-   Дублирование данных: при повторном внесении данных о чем-либо нужно проверять уже существование этих данных, дабы не получить их повторение или противоречие, из-за чего запись становится медленной
-   Зависимость от типов данных. Иногда необходимо увеличить количество символов для поля какого-либо типа данных, но тогда это нужно делать и для всех остальных полей этого типа - ресурсоемко
-   Когда над файлом работает команда, то необходима договоренность о структурах хранения файла
-   Невозможность сделать файловое хранилище, одновременно эффективно для записи и чтения. Существуют два возможных варианта организации файлов: **неупорядоченные** (вставка О(1), поиск О(n)) и **упорядоченные** (вставка O(n), поиск O(log(n)))

#### 4. Трехуровневая архитектура ANSI/SPARC.

**Архитектура ANSI-SPARC (также трёхуровневая архитектура)** определяет
принцип, согласно которому рекомендуется строить системы управления
базами данных (СУБД).

**Цель трехуровневой архитектуры** заключается в отделении
пользовательского представления базы данных от ее физического
представления (из Конноли).

Ниже перечислено несколько **причин**, **по которым желательно выполнить
такое разделение** (из Конноли).

-   Каждый пользователь должен иметь возможность обращаться к одним и тем же данным, реализуя свое собственное представление о них.
-   Каждый пользователь должен иметь возможность изменять свое представление о данных, причем это изменение не должно оказывать влияния на других пользователей. Пользователи не должны непосредственно иметь дело с такими подробностями физического хранения данных в базе, как индексирование и хеширование (приложение В). Иначе говоря, взаимодействие пользователя с базой не должно зависеть от особенностей хранения в ней данных.
-   Администратор базы данных (АБД) должен иметь возможность изменять структуру хранения данных в базе, не оказывая влияния на пользовательские представления.
-   Внутренняя структура базы данных не должна зависеть от таких изменений физических аспектов хранения информации, как переключение на новое устройство хранения.
-   АБД должен иметь возможность изменять концептуальную структуру базы данных без какого-либо влияния на всех пользователей.

**Три уровня системы** (из Конноли):

-   **Внешний (пользовательский)** - это представление базы данных с точки зрения пользователей. Этот уровень описывает ту часть базы данных, которая относится к каждому пользователю.   EX: пользователю важен возраст сотрудника, но с точки зрения хранения, мы будем хранить не возраст, а дату рождения или UNIXtime (количество секунд, прошедших с 1 января 1970 года).

-   **Промежуточный (концептуальный)** - это обобщающее представление базы данных. Этот уровень описывает то, какие данные хранятся в базе данных, а также связи, существующие между ними.  
      
Компоненты представленные на концептуальном уровне:  
- Все сущности, их атрибуты и связи;  
- Накладываемые на данные ограничения;  
- Семантическая информация о данных;  
- Информация о мерах обеспечения безопасности и поддержки целостности данных.

-   **Внутренний** - это физическое представление базы данных в компьютере. Этот уровень описывает, как информация хранится в базе данных.

На внутреннем уровне хранится следующая информация:  
- Распределение дискового пространства для хранения данных и
индексов;  
- Описание подробностей сохранения записей (с указанием реальных
размеров сохраняемых элементов данных);  
- Сведения о размещении записей;  
- Сведения о сжатии данных и выбранных методах их шифрования.

**Физический уровень** - уровень контролируемые ОС, но под управлением СУБД.

> <img src="img\media\image10.png" style="width:4.70313in;height:3.67582in" />

#### 5. Модель сущность-связь. Классификация сущностей, атрибутов и связей. Нотация Чена для представления модели сущность-связь. 

**Модель сущность связь - ER-модель**

История: была предложена известным теоретиком данных Питером Ченом в
1976 году. Суть: основные объекты, с которыми работает, - сущности и
связи.

**Сущность** – множество экземпляров, реальных или абстрактных,
однотипных объектов предметной области.  
**Классификация сущностей:**

-   **Сильные сущности.** Существуют независимо от других сущностей.
-   **Слабые сущности.** Существуют только в связи с другой сущностью (слабой или сильной).

**EX**: Есть БД для электронного магазина, есть сущности клиент и заказ.
Тогда клиент – сильная сущность (может существовать без заказа, ex:
сразу после регистрации на сайте), а заказ – слабая (так как заказ не
может быть без клиента).

**Атрибут (Чен)** – это функция, отображающая набор сущностей в набор
значений или в декартово произведение набора значений. Сущность
фактически определяется как совокупность атрибутов.  
**EX**: студент имеет следующие атрибуты: возраст, цвет волос, табельный
номер. Множество значений атрибутов называется **доменом**.  
**EX**: возраст – атрибут: возраст отображается в натуральные числа от 0
до 99. Ключевой атрибут (ключ сущности) – это группа атрибутов такая,
что отображение набора сущностей в соответствующую группу наборов
значений является взаимно-однозначным.

**EX**: табельный номер – ключевой атрибут, так как каждая сущность
студента взаимно-однозначно отображается в табельный номер.

**Классификация атрибутов:**

-   **Простые и составные**
    -   Простые
    -   Составные (**EX**: адрес, в котором указаны город, индекс, улица, дом, корпус)

-   **Обязательные и необязательные**
    -   Обязательные. **EX**: имя, фамилия, отчество
    -   Необязательные. **EX**: номер телефона

-   **Однозначные и многозначные**
    -   Однозначные.
    -   Многозначные: для одной и той же сущности принимают несколько значений. **EX**: номер телефона (у одного человека их может быть несколько)

**Связь** – это ассоциация, установленная между несколькими сущностями.

Также между сущностями может быть несколько связей. Связи также могут
обратимыми.

**Арность связи** – количество сущностей в связи.

**Теорема**: любая n-арная связь может представлена как совокупность
бинарных. Согласно Чену, все связи должны быть связаны семантикой.

**Типы (кардинальность) связей:**

-   **1:1 (один к одному)** – связь, в которой каждый экземпляр сущности
    > А связан не более, чем с одним (то есть связь может как быть, но
    > может так и не быть) экземпляром сущности B, а каждый экземпляр
    > сущности B связан не более, чем с одним экземпляром сущности A.

-   **1:n (один ко многим**) – связь, в которой каждый экземпляр
    > сущности A может быть связан с 0, 1 или несколькими экземплярами
    > сущности B, а каждый экземпляр сущности B связан не более, чем с
    > одним экземпляром сущности A.

-   **n:n (многие ко многим)** - связь, в которой каждый экземпляр
    > сущности A может быть связан с 0, 1 или несколькими экземплярами
    > сущности B, а каждый экземпляр сущности B может быть связан с 0, 1
    > или несколькими экземплярами сущности A.

**EX:**

-   **1:1**

    -   У одного отдела может быть только один руководитель, и один
        > руководитель может руководить только одним отделом. o

    -   У каждого отдела существует сотрудник, который является
        > руководителем, но не каждый сотрудник является руководителем
        > отдела (такая связь является модальной). Иными словами, у
        > сотрудника может быть 0 или 1 отдел, которыми он руководит, а
        > у отдела может быть только 1 сотрудник, который им руководит.

-   **1:n**

    -   Сотрудник может работать только в 1 отделе, но в 1 отделе может
        > работать более, чем 1 сотрудник. Здесь также присутствует
        > модальность: если есть сотрудник, то он он всегда работает в
        > каком-то отделе, поэтому у сотрудника должен быть отдел,
        > значит, модальность отдела равна 1. Но может быть отдел, в
        > котором нет вообще или есть несколько сотрудников
        > (руководителей не рассматриваем), значит, модальность
        > сотрудников равна 0 или n. На схемах обозначается “вороньей
        > лапкой”.

-   **n:n**

    -   Связь “преподаватель читает дисциплину”. У преподавателя более,
        > чем 1 дисциплина. У преподавателя модальность равна 1, то есть
        > у дисциплины должен быть преподаватель, но у преподавателя
        > может и не быть дисциплины (ему дали передохнуть).

**Нотация Чена для представления модели сущность - связь.**

Множества сущностей изображаются в виде прямоугольников, множества
отношений изображаются в виде ромбов.  
Если сущность участвует в отношении, они связаны линией.  
Если отношение не является обязательным, то линия пунктирная.  
Атрибуты изображаются в виде овалов и связываются линией с одним
отношением или с одной
сущностью.<img src="img\media\image2.png" style="width:5.15144in;height:4.81771in" />

**EX:**

<img src="img\media\image3.png" style="width:4.11701in;height:1.10938in" />

####  

#### 6. Логическая и физическая модели данных. Содержание уровней.

**Логическая модель данных** является источником информации для этапа
физического проектирования и обеспечивает разработчика физической базы
данных средствами поиска компромиссов, необходимых для достижения
поставленных целей, что очень важно для эффективного проектирования.
Именно на этом этапе при переходе от концептуального, разработчик думает
о типах данных, ограничениях и.т.д  
**Построение физической модели БД** производится на основе
логической/даталогической. На этом уровне проектирования разработчику
базы данных необходимо принять базовые правила определения пространства
имен, которые будут применяться в базе данных.  
Такое описание пространства имен позволит стандартизировать наименования
объектов базы данных и однозначно интерпретировать используемые имена
при написании программных кодов обработки и выборки данных.

В общем виде физический уровень моделирования предполагает описание
структур данных, но используемым в базе данных представлениям, шаблоны
программных кодов для хранимых процедур и триггеров. Фактически
физический уровень представляется программным уровнем представления базы
данных.

СУБД дает возможность пользователю построить индивидуальную физическую
модель.

####  

#### 7. Иерархическая и сетевая модели данных: составы моделей, преимущества и недостатки.

**Концепция:** связи между корпоративными связями - это, как правило,
связи подчинения. Иерархическая модель сводится к тому, что мы храним
дерево или множество деревьев.

<img src="img\media\image23.png" style="width:6.27083in;height:2.90278in" />

**Поле данных** - минимальная неделимая единица данных  
**Сегмент данных** - совокупность полей данных. (Сотрудник -
совокупность полей фамилии, имени отчества, номера и должности)  
**Экземпляр сегмента** - конкретные значения полей. (Заполняя данные о
человеке, мы получаем конкретный экземпляр сегмента)  
**Ключ** - значение одного из полей, уникальное для всех экземпляров
данного сегмента

**Плюсы**:

-   просто

-   Такая связь занимает мало памяти

**Минусы**:

-   Проблема возникает, когда мы хотим получить список всех сотрудников
    > данного отдела. Тогда нам нужно будет посмотреть всех сотрудников,
    > чтобы определить, кто из них относится к данному отделу, то есть
    > мы можем только подниматься наверх от сотрудника к отделу, а
    > спускаться - нет. В больших базах данных с уровнями иерархиями
    > 15-20 это весьма долго

-   Целостность данных. После удаления отдела, нужно посмотреть всех
    > сотрудников и тем, кто там работал поменять идентификатор.
    > *Альтернатива*: для каждого дерева мы храним полностью всю
    > структур дерева вниз,то есть для отделов в некоторой структуре
    > храним множество всех его сотрудников. ТАк можно быстро получать
    > информацию, но любые изменения в данных мы должны контролировать
    > во всех структурах и деревьях.

#### 8. Реляционная и постреляционная модели данных: составы моделей, преимущества и недостатки. 

1.  **Реляционная модель данных**

> **Концепция**: значение одного из атрибутов берется из некоторого
> атрибута другого отношения. Таблица описывает отношение некоторого
> множества атрибутов.
>
> **Отношение** - плоская таблица  
> **Атрибуты отношения** - столбцы таблицы  
> **Кортежи (записи)** - строки таблицы  
> **Поле** - пересечение строки и столбца  
> Иными словами, мы имеем некоторое множество кортежей (строк), каждый
> из которых состоит из некоторого множества атрибутов (столбцы). При
> этом поле (пересечение строки и столбца - значение ячейки) - значение
> какого-либо атрибута в рамках конкретного кортежа  
> В реляционной модели данных, в отличие от иерархической, мы не
> разделяем хранение данных от хранения связей о том, как связаны эти
> данные: мы храним и данные, и связи с помощью таблиц (отношений)  
> **Пример**: Что делать в рамках реляционной модели в случаях, если,
> например, у сотрудника есть два номера телефона? (Варианты в формате
> “ответ - оценка ответа”)

-   **Вариант 1**: Дублировать сотрудника - плохо, так как мы
    > присваиваем два разных ID одному и тому же человеку -&gt;
    > нарушение целостности

-   **Вариант 2**: хранить два телефона в одной ячейка - непонятно, что
    > делать с целостностью атрибутов, так как атрибут “телефон”
    > перестает быть атомарным (то бишь становится неопределенным)

-   **Вариант 3**: Сделать отдельную таблицу (так обычно и делают) для
    > хранения всевозможных телефонов и между ними ставим
    > таблицу-связку, в которой будут храниться пары: идентификатор
    > телефона, идентификатор сотрудника. Тогда если у сотрудника 2
    > телефона, то в этой таблицу будут 2 записи. Как недостаток,
    > получаем избыточность с дополнительными таблицами - теперь нужно
    > JOIN’ить таблицы, и поиск займет больше времени. Чтобы устранить
    > данный недостаток были придуманы постреляционные базы данных.

> **Плюсы**:

-   Простота. В реляционной модели всего одна информационная
    > конструкция, которая формализует табличное представление данных,
    > привычное для пользователей.

-   Теоретическое обоснование. Наличие теоретически обоснованных методов
    > нормализации отношений позволяет получать БЖ с заданными
    > характеристиками.

-   Независимость данных. Когда необходимо изменить структуру
    > реляционной БД, это, как правило, приводит к минимальным
    > изменениям в прикладных программах.

> **Минусы**:

-   Низкая скорость при выполнении операции соединения

-   Большой расход памяти для представления реляционной БД

1.  **Постреляционная модель данных**  
    > Постреляционная БД по логике такая же, как и реляционная, но
    > снимает запрет на неделимость поля, то есть мы разрешаем полю с
    > помощью перечисления или хранения какой-нибудь структуры данных
    > хранить какие-то не атомарные значения, то есть что-то являющееся
    > совокупностью отдельных значений.  
    > **Минусы:**

-   Как хранить многозначные поля? Можно разделять данные двоеточием, но
    > что делать, если нужно написать двоеточие? Как итог,
    > дополнительные сложности реализации

-   Нельзя проверять БД на целостность данных

####  

#### 9. Многомерная и объектно-ориентированная модели данных: составы моделей, преимущества и недостатки. 

**Объектно-реляционная модель данных**

Когда пишем код в стиле ООП, то каждый экземпляр класса хранится в БД
(аналог кортежа). При поиске или изменении поля у объекта делаем
соответствующий запрос к БД. JSON – сериализация объекта. Все базы,
которые называются реляционными, по факту являются
объектно-реляционными.

**Многомерная модель данных**

EX: пусть есть данные о продаже: есть товары, которые продавались в
разные месяца, в разном объеме, в разных филиалах. Хочется отвечать на
запросы: сколько товаров данного типа было продано в этот месяц в этом
конкретном филиале. Можно ответить на запрос с помощью GROUP BY, но сама
операция GROUP BY является долгой. Идея такая: будет хранить 3-мерную
таблицу: (товар х месяц х филиал). В каждой ячейке 10 храним информацию,
сколько товаров данного типа было продано в любой месяц в конкретном
филиале. Если нужно добавить еще один атрибут, то мы добавим еще одно
измерение. Концепция: для увеличения скорости ответов на запросы храним
данные в многомерном виде. Итог: быстро отвечаем на запросы, но дорого
по памяти (вероятно, что будет много значений).

####  

#### 10. Реляционная модель данных: терминология, свойства отношений. 

**Отношение** – двумерная таблица, содержащая данные.

**Атрибут** – заголовок столбца данной таблицы.

**Схема отношения** – строка заголовков столбцов (или совокупность
атрибутов).

**Кортеж (1)** – строка таблицы.

**Поле (значение атрибута)** – значение конкретного атрибута в
конкретном кортеже. **Домен** – множество допустимых значений отдельного
атрибута.

**Отношение** – некоторое подмножество декартового произведения доменов.

**Кортеж (2)** – множество конкретных значений атрибутов, где каждое
значение принадлежит соответствующему домену.

**Классификация отношений:**

1\. Именованные и неименованные:

a\. Именованные отношения имеют некоторое уникальное имя

b\. Неимованные отношения не имеют уникального имени.

2\. Базовые и производные

a\. Базовое отношение существует независимо.

b\. Производное отношение существует только в связи с некоторыми
базовыми.

**EX**: результат выполнения запроса является неименованным производным
отношением, так как не имеет имени и существует только при наличии
базовых таблиц.

Кодд (создатель реляционной модели данных) сформулировал **6 свойств**,
которыми должна обладать реляционная модель (сейчас это не так):

1\. Уникальность имени отношения в реляционной схеме, т.е. каждая
таблица должна иметь уникальное имя. Внимание: речь здесь не идет про
базы данных.

2\. Каждая ячейка содержит только одно неделимое значение.

3\. Уникальность имени атрибута (и даже у результатов запроса, так как
результат запроса – это тоже отношение) в пределах отношения, т.е. не
может быть у двух столбцов одно и то же имя в пределах одного отношения.

4\. Все значения атрибута берутся из одного домена (для объектов
существует домен “все, что угодно”, где хранится битовая
последовательность).

5\. В рамках одного отношения каждый кортеж уникален, т.е. не может быть
двух одинаковых строк у одной таблицы.

6\. Порядки следования атрибутов и кортежей не имеют значения, т.е.
столбцы и строки в отношении неупорядоченны.

####  

#### 11. Реляционная модель данных: виды ключей, реализация различных типов связей, виды целостности. 

**Виды ключей**

-   **Супер-ключ**

> Супер-ключ – это атрибут или множество атрибутов, единственным образом
> идентифицирующие кортеж.
>
> EX: Cхема отношения также является супер-ключом (так как любой кортеж
> в рамках одного отношения по Кодду уникален). EX: ID является
> супер-ключом.

-   **Потенциальный ключ**

> Потенциальный ключ – это супер-ключ, который не содержит подмножества,
> также являющегося суперключом данного отношения.
>
> Иными словами, потенциальный ключ – это минимальный супер-ключ.
> Очевидно, что на одном отношении можно создать несколько потенциальных
> ключей.

-   **Первичный ключ**

> Первичный ключ (primary key, PK) – потенциальный ключ, который выбран
> для уникальной идентификации кортежа отношения.
>
> Первичный ключ существует только один для данного отношения.

-   **Внешний ключ**

> Внешний ключ (foreign key, FK) – атрибут или множество атрибутов
> отношения, которое соответствует потенциальному ключу некоторого,
> может быть, того же самого отношения.
>
> У каждого отношения мы можем выделить первичный ключ. С помощью
> первичного и внешних ключей можно описывать связи между различными
> отношениями: если мы берем значение некоторого атрибута в отношении из
> множества значений, являющегося первичным ключом другого отношения, мы
> обеспечиваем связь между этими отношениями. Иными словами, мы ставим
> биекцию кортежам из одного отношения в кортежи другого отношения.

**Виды связей в реляционной модели**

-   Связь 1:1

> Почему мы все равно храним две таблицы, связанные первичным ключом, по
> отдельности? С точки зрения безопасности, проще всего ограничить
> доступ на уровне таблицы, значительно сложнее на уровне столбца, и
> намного сложнее на уровне строки.

-   Связь 1:n

> Есть первичный ключ в первой таблице и он подставляется как значение
> внешнего ключа в другом отношении. EX: Студент, номер группы.
>
> Связь n:n Преподаватель, дисциплина. Хранение таблицы связки, куда
> помещаются пары первичных ключей из данных отношений.
>
> Обеспечение целостности данных в реляционной модели
>
> Выделяют два вида целостности данных: целостность сущностей и
> целостность связей (ссылочная целостность).

-   Целостность сущностей

Целостность сущностей означает, что в базовом отношении ни один атрибут
первичного ключа не может содержать NULL-значений. (после внесения
данных вместо NULL может произойти, что у нас будут одинаковые первичные
ключи для двух сущностей).

-   Целостность связей

Целостность связей означает, что каждое значение внешнего ключа должно
обязательно иметь соответствующее значение первичного ключа в другом
отношении. EX: если студент учится в группе с данным ID, то в этой
таблице должна быть группа с этим ID, иначе непонятно, где он учится.

Что делать при удалении данных?

• Вариант 1: удалять соответствующие объекты. EX: Есть студент, у
которого расформировали группу, тогда студента мы тоже удаляем. Простой
способ.

• Вариант 2: каскадное удаление. EX: У компании хранится адрес, у этого
адреса хранится город, для городов указана страна. Удаляем страну -&gt;
так как больше такого города не существует, то удаляем и город -&gt;
удаляем адрес -&gt; удаляем компанию.

• Вариант 3: замена на NULL значения. EX: Удалили страну и в таблице
городов для городов, которые были в этой стране, поставили NULL. При
этом сохранилась связь компания-город.

####  

#### 12. Операции реляционной алгебры: проекция, выборка, объединение, разность, пересечение. 

-   **Проекция**. Результатом проекции является отношение, содержащее
    > вертикальное подмножество исходного отношения, то есть формируется
    > отношение, имеющее лишь часть столбцов.

-   **Выборка** (по некоторому предикату F). Результатом выборки
    > является отношение, содержащее только те кортежи, которые
    > удовлетворяют предикату F (любое суждение, которое может быть
    > построено для кортежей.

-   **Объединение**. Результатом объединения двух отношений R и S
    > определяет новое отношение, включающее кортежи, которые есть в R
    > или S, исключая дубликаты (иначе противоречие по Кодду). Для того,
    > чтобы эта операция была выполнимой, отношения R и S должны быть
    > совместимы по объединению, то есть в отношениях R и S должно быть
    > одинаковое количество атрибутов, и эти атрибуты должны быть
    > попарно взяты из одинакового домена (одинаковость имен при этом не
    > требуется). Домены нового отношения при этом сохраняются.

-   **Разность**. Результатом разности двух совместимых отношений R и S
    > являются кортежи, которые есть в R, но нет в S.

-   **Пересечение**. Пересечение двух совместных отношений R и S – это
    > отношение, состоящее из кортежей, которые есть и в R, и в S.

####  

#### 13. Операции реляционной алгебры: Тета-соединение, эквисоединение, естественное соединение, левое внешнее соединение, полусоединение. 

-   **Theta-соединение**. Theta-соединение (по предикату F) определяет
    > отношение, которые содержит кортежи из декартового произведения R
    > и S, удовлетворяющие предикату F, имеющий вид: F = R.ai theta
    > S.bj, theta принадлежит множеству {=, &lt;, &gt;, &lt;=, &gt;=, …}
    > – множеству операций попарного сравнения кортежей по некоторому
    > атрибуту из R с некоторым атрибутом из S.

-   **Экви-соединение**. Экви-соединение – theta-соединение, где theta
    > является операцией ‘=’.

-   **Натуральное (естественное) соединение.** Натуральное соединение
    > отношений R и S – соединение по эквивалентности, выполненное по
    > всем общим атрибутам, из результатов которого исключается по
    > одному экземпляру каждого общего атрибута.

> EX: есть две таблицы с общими атрибутами, соединяя их, получаем
> кортежи, у которых дублируется атрибуты, по которым проводилось
> сравнение, далее убираем один из столбцов атрибутов.

-   **Левое внешнее соединение.** Левое внешнее соединение отношений R и
    > S – соединение, при котором в результирующее отношение включаются
    > также кортежи отношения R, не имеющие совпадающих значений в общих
    > столбцах отношения S. Фактически, мы дополняем натуральные
    > соединения теми кортежами из R, для которых не было совпадающих
    > значений в S, и тогда для атрибутов, которые были определены на S
    > ставим NULL-значения.

-   **Полусоединение**. Полусоединение отношений R и S – отношение,
    > содержащее кортежи из R, которые входят в соединение отношений R
    > и S. Фактически, берется theta-соединение R и S по какому-то
    > предикату theta, но выводим только кортежи из R, то есть выводим
    > данные из одной таблицы из тех строк, которые соответствуют
    > значениям какой-то другой таблицы.

####  

#### 14. Структура и порядок выполнения предложения Select в SQL. 

\[\] - необязательные параметры

{} - обязательно один из вариантов перечисленных через \|

**Структура предложения Select:**

SELECT \[distinct \| all\] {\* \| \[ColumnExpression \[as NewName\]\]
\[, ...\]}

FROM tableName \[as NewName\] \[{INNER \| {LEFT \| RIGHT \| FULL} \|
OUTER \| CROSS}

JOIN OtherTable \[as NewName\] ON Predicate\]

\[WHERE Condition\]

\[GROUP BY ColumnList\]

\[HAVING Condition\]

\[ORDER BY ColumnList \[ASC \| DESC\]\]

**Порядок выполнения предложения:**

1.  FROM

2.  ON

3.  JOIN

4.  WHERE

5.  GROUP BY

6.  HAVING

7.  SELECT

8.  DISTINCT

9.  ORDER BY

####  

#### 15. Алгоритмы реализации соединений отношений в SQL. 

Таблицы: R, S

Поля: R.r, S.s

Тривиальный алгоритм:  
for r in R:

for s in S:

if Θ(r, s):

concat(r, s)

Оптимизация:

R.sort(r)

S.sort(s)

“Merge sort”

while not end\_of\_R and not end\_of\_S:

if R.r &lt; S.s:

next R

if R.r == S.s:

concat(r, s)

next R

if R.r &gt; S.s:

next S

####  

#### 16. Нормализация реляционной модели: избыточность, аномалии, суть метода нормальных форм. Виды зависимостей между атрибутами. 

#### 17. Первая и вторая нормальные формы. Примеры. 

**Первая нормальная форма:**  
**Отношение находится в 1НФ**, если все его атрибуты являются простыми
(элементарными, неделимыми).

**EX:** Формально ФИО – три разных атрибута, поэтому не соответствует
1НФ, но на самом деле на практике удобнее использовать именно ФИО (или
полное имя) как один простой атрибут.

**Вторая нормальная форма:**

**Отношение находится в 2НФ**, если оно находится в 1НФ и каждый
неключевой атрибут функционально полно зависит от первичного ключа.

**EX:** Имеем три неключевых атрибута: форма обучения, кафедра и
факультет. Форма обучения функционально полно зависит от ключа, а
кафедра и факультет зависят только частично (только от группы), значит,
отношение не находится в 2НФ.

\*Если первичный ключ является простым, то если отношение находится в
1НФ, то оно автоматически находится и в 2НФ, так как по сути 2НФ
касается только составных ключей.

Чтобы привести модель к 2НФ, делаем декомпозицию отношения.

**EX:** разобьем отношение на следующие:

• Студент: ФИО – Группа – Форма обучения, PK: (ФИО, группа)

• Группа: Группа – Кафедра – Факультет, PK: (группа)

Оба данных отношения находятся в 2НФ, так как теперь кафедра и факультет
полностью зависят от группы.

#### 18. Третья нормальная форма. Примеры. 

**Отношение находится в 3НФ**, если оно находится в 2НФ и все неключевые
атрибуты взаимно независимы и полностью зависят от первичного ключа.

**Отношение находится в 3НФ**, если оно находится в 2НФ и ни один
неключевой атрибут не находится в транзитивной функциональной
зависимости от потенциального ключа.

\*Если отношение находится в 2НФ и есть только один неключевой атрибут,
то это отношение автоматически находится и в 3НФ.

**EX:** • Студент: ФИО – Группа – Форма обучения, PK: (ФИО, группа) –
3НФ

• Группа: Группа – Кафедра – Факультет, PK: (группа) – не 3НФ, так как
группа → кафедра и группа → факультет, а значит кафедра → факультет

Чтобы решить проблему, делаем декомпозицию второго отношения:

• Студент: ФИО – Группа – Форма обучения, PK: (ФИО, группа)

• Группа: Группа – Кафедра, PK: (группа)

• Кафедра: Кафедра – Факультет, PK: (кафедра)

В итоге мы получили базу данных, удовлетворяющую 3НФ

####  

#### 19. Нормальная форма Бойса-Кодда. Примеры. 

**Отношение находится в БКНФ**, если детерминанты всех зависимостей
являются потенциальными ключами.

**EX**: полное имя полностью зависит от номера студента, но при этом
номер студента не является потенциальным ключом. Чтобы привести исходное
отношение к БКНФ, сделаем декомпозицию отношения:

• Номер студента – Полное имя, PK: (номер студента)

• Номер студента – Номер проекта – Роль, PK: (номер студента, номер
проекта)

\*Если ключ не составной, то отношение автоматически является БКНФ.

####  

#### 20. Четвертая нормальная форма. Примеры. 

**EX**: Дисциплина: Дисциплина – Лектор – Практик, PK: (дисциплина).

Данное отношение является 3НФ и БНКФ.

\*Данное отношение реализует многозначную зависимость, то есть ни
лектор, ни практик друг от друга не зависят, но они оба зависят от
дисциплины.

**Отношение является 4НФ**, если оно находится в БКНФ и не содержит
нетривиальных многозначных зависимостей. Чтобы привести отношение к 4НФ,
сделаем декомпозицию

(Вариант 1):

• Дисциплина – Лектор, PK: (Дисциплина)

• Дисциплина – Практик, PK: (Дисциплина)

Вариант 2:

• Дисциплина – Преподаватель – Роль, PK: (Дисциплина, Роль)

####  

#### 21. Использование индексов для повышения производительности. Виды индексов. 

**Индекс.** Структура данных, которая помогает СУБД быстрее обнаружить
отдельные записи в файле и сократить время выполнения запросов
пользователей.

Использование индексации увеличивает скорость чтения и поиска, но
замедлят изменение.

**Виды индексов:**

-   **Первичный индекс**- файл упорядочен по первичному ключу и по этому
    > ключу строится индекс, индекс всегда уникальный.

-   **Индекс кластеризации** - файл данных последовательно
    > упорядочивается по неключевому полю, и на основе этого неключевого
    > поля формируется поле индексации, поэтому в файле может быть
    > несколько записей, соответствующих значению этого поля
    > индексации.**  
    > Неключевое поле** называется атрибутом кластеризации.  
    > Индекс кластеризации может появляться естественным образом.  
    > **EX**: ФИО

-   **Вторичный индекс** - индекс, который определен на поле файла
    > данных, отличном от поля, по которому выполняется упорядочение.

**Подвиды индексов:**

-   **Плотный индекс** имеет индексные записи для всех значений ключа
    > поиска в данном файле.

-   **Разреженный индекс** содержит индексные записи только для
    > некоторых значений ключа поиска в данном файле. Как правило,
    > кластерный индекс - разреженный индекс (индекс указывает на начало
    > кластера).  
    > Разреженный индекс не всегда является индексом кластеризации.
    > Разреженный индекс может применяться к структурам, которые не
    > обладают естественной кластеризацией.  
    > **EX:** кластеризации по первым символам ФИО

Ключ поиска для индекса может состоять из нескольких полей.

При объединение таблиц индекс теряет свою эффективность. Необходимо
перестраивать индексы.

Индексы можно хранить как двоичное дерево поиска (AVL - дерево).  
<img src="img\media\image4.png" style="width:6.27083in;height:4.48611in" /><img src="img\media\image5.png" style="width:5.59203in;height:0.90104in" />

#### 22. Использование представлений для повышений производительности и безопасности. Виды представлений. Преимущества и недостатки представлений. 

<img src="img\media\image22.png" style="width:6.27083in;height:6.23958in" />

<img src="img\media\image16.png" style="width:6.27083in;height:6.82292in" />

<img src="img\media\image17.png" style="width:6.27083in;height:7.16667in" />

####  

#### 23. Транзакции. Понятие транзакции. Свойства транзакции.

**Транзакция -** это последовательность операторов манипулирования
данными, выполняющимися как единое целое(все или ничего) и переводящая
базу данных из одного целостного состояния в другое целостное состояние.

**Свойства транзакций:**

-   **Атомарность**. Транзакция выполняется как атомарная операция -
    > либо выполняется вся транзакция целиком, либо она целиком не
    > выполняется.

-   **Согласованность**. Транзакция переводит базу данных из одного
    > согласованного (целостного) состояния в другое согласованное
    > (целостное) состояние. Внутри транзакции согласованность базы
    > данных может нарушаться.

-   **Изоляция**. Транзакции разных пользователей не должны мешать друг
    > другу (например, как если бы они выполнялись строго по очереди).  
    > **Долговечность**. Если транзакция выполнена, то результаты ее
    > работы должны сохраниться в базе данных, даже если в следующий
    > момент произойдет сбой системы.

**Возможны два варианта завершения транзакции.** Если все операторы
выполнены успешно и в процессе выполнения транзакции не произошло
никаких сбоев программного или аппаратного обеспечения, транзакция
фиксируется.  
**Фиксация транзакции** — это действие, обеспечивающее запись на диск
изменений в базе данных, которые были сделаны в процессе выполнения
транзакции.

#### 24. Проблемы конкурирующих транзакций и методы их решения. Уровни изоляции транзакций. 

**Проблемы конкурирующих транзакций:**

-   **Проблема потерянного обновления** (англ. lost update) – несколько
    > пользователей изменяют одну и ту же строку, основываясь на ее
    > начальном значении, в результате часть данных будет потеряна, так
    > как каждая последующая транзакция перезапишет изменения, сделанные
    > предыдущей;

-   **Проблема "грязного чтения"** (англ. dirty read) может возникнуть
    > при чтении транзакцией записи, которая изменена, но еще не
    > сохранена в БД (данные изменены еще не завершившейся транзакцией,
    > которая после будет отменена);

-   **Проблема неповторяемого чтения** (англ. non-repeatable reads) –
    > при повторном чтении данных, уже считанных ранее, транзакция
    > обнаруживает модификации или удаления, вызванные другой
    > завершенной транзакцией; подобное изменение может нарушить логику
    > работы транзакции;

-   **Проблема чтения фантомов** (англ. phantom reads) появляется, когда
    > при повторном чтении данных транзакция обнаруживает новые строки,
    > вставленные или измененные другой транзакцией, завершенной после
    > предыдущего чтения этого набора данных.

**Уровни изоляции транзакций** (каждый последующий уровень поддерживает
требования предыдущего и налагает доп. ограничения):

-   **Уровень "незавершенное чтение"** (англ. READ UNCOMMITTED)
    > позволяет избежать только потерянного обновления. Этот уровень
    > требует, чтобы изменять данные могла только одна транзакция; если
    > другой транзакции необходимо изменить те же данные, она должна
    > ожидать завершения первой транзакции.

-   **Уровень "завершенное чтение"** (англ. READ COMMITTED)
    > дополнительно позволяет избежать "грязного чтения". Если
    > транзакция начала изменение данных, то никакая другая транзакция
    > не сможет прочитать их до завершения первой.

-   **Уровень "воспроизводимое чтение"** (англ. REPEATABLE READ) в
    > дополнение обеспечивает повторяемость чтения: если транзакция
    > считывает данные, то никакая другая транзакция не сможет их
    > изменить, и при повторном чтении они будут находиться в том же
    > состоянии.

-   **Уровень "сериализуемость"** (англ. SERIALIZABLE), самый высокий
    > уровень, позволяющий справиться с проблемой чтения фантомов. Если
    > транзакция обращается к данным, то никакая другая транзакция не
    > сможет добавить новые или изменить существующие строки, которые
    > могут быть считаны при выполнении транзакции. Подобная блокировка
    > накладывается не на конкретные строки таблицы, а на строки,
    > удовлетворяющие определенному логическому условию.

**Сериализуемость** означает, что две транзакции обрабатываются
параллельно таким образом, что их результаты согласуются с результатами,
которые могут быть получены при последовательной обработке этих
транзакций.

#### 25. Иерархия уровней безопасности по оранжевой книге. Понятия идентификации и аутентификации. 

<img src="img\media\image11.png" style="width:2.78125in;height:3.61458in" />

#### Уровень C - Произвольное управление доступом

Класс C1 обеспечивает базовый уровень безопасности, разделяя
пользователей и данные. Информационные системы, принадлежащие к данному
классу, должны отвечать следующим основным требованиям:

-   Доверенная база управляет доступом именованных пользователей к
    > именованным объектам;

-   Пользователи четко идентифицируют себя;

-   Аутентификационная информация пользователей защищена от
    > несанкционированного доступа;

-   Доверенная вычислительная база имеет изолированную область для
    > собственного выполнения, защищенную от внешних воздействий;

-   Есть в наличии аппаратные или программные средства, позволяющие
    > периодически проверять корректность функционирования аппаратных и
    > микропрограммных компонентов доверенной вычислительной базы;

-   Защитные механизмы протестированы на отсутствие способов обхода или
    > разрушения средств защиты доверенной вычислительной базы;

-   Описаны подход к безопасности и его применение при реализации
    > доверенной вычислительной базы.

**Класс C2 (в дополнение к требованиям к C1) гарантирует ответственность
пользователей за свои действия:**

-   Права доступа гранулируются с точностью до пользователя, а доступ к
    > любому объекту контролируется;

-   При выделении объекта из пула ресурсов доверенной вычислительной
    > базы, устраняются следы его использования;

-   Каждый пользователь системы уникальным образом идентифицируется, а
    > каждое регистрируемое действие ассоциируется с конкретным
    > пользователем;

-   Доверенная вычислительная база позволяет создавать, поддерживать и
    > защищать журнал регистрационной информации, касающейся доступа к
    > объектам, которые контролируются базой;

-   Тестирование подтверждает отсутствие видимых недостатков в
    > механизмах изоляции ресурсов и защиты регистрационной информации.

#### Уровень B - Принудительное управление доступом

**Класс B1 (в дополнение к требованиям к C2):**

-   Доверенная вычислительная база управляет метками безопасности,
    > ассоциированными с каждым субъектом и хранимым объектом;

-   Доверенная вычислительная база обеспечивает реализацию
    > принудительного управления доступом всех субъектов ко всем
    > хранимым объектам;

-   Доверенная вычислительная база обеспечивает взаимную изоляцию
    > процессов путем разделения их адресных пространств;

-   Специалисты тщательно анализируют и тестируют архитектуру и исходный
    > код системы;

-   Существует неформальная или формальная модель политики безопасности,
    > поддерживаемая доверенной вычислительной базой.

**Класс B2 (в дополнение к требованиям к B1):**

-   Все ресурсы системы, прямо или косвенно доступные субъектам,
    > снабжаются метками секретности;

-   В доверенной вычислительной базе поддерживается доверенный
    > коммуникационный путь для пользователя, выполняющего операции
    > начальной идентификации и аутентификации;

-   Предусмотрена возможность регистрации событий, связанных с
    > организацией тайных каналов обмена с памятью;

-   Доверенная вычислительная база внутренне структурирована на хорошо
    > определенные, относительно независимые модули;

-   Системный архитектор тщательно анализирует возможность организации
    > тайных каналов обмена с памятью и оценивает максимальную
    > пропускную способность каждого выявленного канала;

-   Продемонстрирована относительная устойчивость доверенной
    > вычислительной базы к попыткам проникновения;

-   Модель политики безопасности является формальной; для доверенной
    > вычислительной базы существуют описательные спецификации верхнего
    > уровня, точно и полно определяющие ее интерфейс;

-   В процессе разработки и сопровождения доверенной вычислительной базы
    > используется система управления конфигурациями, обеспечивающая
    > контроль изменений в спецификациях верхнего уровня, архитектурных
    > данных, исходных текстах, работающей версии объектного кода,
    > тестовых данных и документации;

-   Тесты подтверждают действенность мер по уменьшению пропускной
    > способности тайных каналов передачи информации.

**Класс B3 (в дополнение к требованиям к B2):**

-   для произвольного управления доступом используются списки управления
    > доступом с указанием разрешенных режимов;

-   предусмотрена возможность регистрации появления и накопления
    > событий, несущих угрозу нарушения политики безопасности системы.
    > Администратор безопасности немедленно получает сообщения о
    > попытках нарушения политики безопасности; система, в случае
    > продолжения таких попыток сразу их пресекает;

-   доверенная вычислительная база спроектирована и структурирована
    > таким образом, чтобы использовать полный и концептуально простой
    > защитный механизм с точно определенной семантикой;

-   анализируется и выявляется возможность временных тайных каналов;

-   существует роль администратора безопасности, получить которую можно
    > только после выполнения явных, протоколируемых действий;

-   имеются процедуры и/или механизмы, позволяющие без ослабления защиты
    > произвести восстановление после сбоя;

-   продемонстрирована устойчивость доверенной вычислительной базы к
    > попыткам проникновения.

#### Уровень A - Верифицируемая безопасность

**Класс A1 (в дополнение к требованиям к B3):**

-   Тестирование продемонстрировало то, что реализация доверенной
    > вычислительной базы соответствует формальным спецификациям
    > верхнего уровня;

-   Представлены формальные спецификации верхнего уровня; используются
    > современные методы формальной спецификации и верификации систем;

-   Механизм управления конфигурациями распространяется на весь
    > жизненный цикл и все компоненты системы, имеющие отношение к
    > [обеспечению](https://arinteg.ru/articles/uslugi-informatsionnoy-bezopasnosti-25801.html)
    > безопасности;

-   Описано соответствие между формальными спецификациями верхнего
    > уровня и исходными текстами

#### 26. Избирательный (дискреционный) контроль доступа. Ролевой контроль доступа. 

<img src="img\media\image9.png" style="width:6.27083in;height:4.23958in" />

<img src="img\media\image19.png" style="width:6.27083in;height:4.27083in" />

#### 27. Мандатный контроль доступа. <img src="img\media\image8.png" style="width:6.27083in;height:7.48611in" />

#### 28. Аудит и шифрование данных в БД. 

<img src="img\media\image12.png" style="width:6.27083in;height:2.4375in" />

<img src="img\media\image18.png" style="width:6.27083in;height:7.79167in" />

<img src="img\media\image6.png" style="width:6.27083in;height:1.66667in" />

#### 29. Распределенные БД. Определение. Стратегии размещения данных в системе, их достоинства и недостатки. Понятие прозрачности. 

1.  **Предпосылки появления распределенной БД  
    > **- Базы данных стали узким местом в развивающейся многозвенной
    > клиент-серверной архитектуры  
    > - Проблемы медленной памяти (не было “бума” в производстве жестких
    > дисков и тд, ssd-дисков недостаточно)

2.  **Определение**  
    > Набор логически связанных между собой разделяемых данных и их
    > описаний, которые физически распределены по нескольким
    > вычислительным узлам некоторой сети

3.  **Стратегии размещения данных в системе, их достоинства и
    > недостатки  
    > **- Раздельное размещение - разбиение данных на непересекающиеся
    > фрагменты, причем каждый фрагмент располагается на отдельном
    > узле.  
    > **Плюсы**: все фрагменты в одном экземпляре -&gt; нет накладных
    > затрат; решение проблемы с объемами данных  
    > **Минусы**: потеря надежности (если сбой, то не будет репликатов,
    > которые выручат); производительность и доступность низкие (поиск и
    > прочее будут долгими)  
    > - Размещение с полной репликацией - в каждом узле располагаются
    > полные копии всей базы данных  
    > **Плюсы**: надежность и доступность на высоте  
    > **Минусы**: накладные и телекоммуникационные расходы;
    > производительность при попытке доступе данных (по причине того,
    > что при синхронизации данных данные блокируются, могут быть
    > сбои)  
    > - Размещение с выборочной репликацией - собственноручное
    > выполнение репликации и назначение места хранения репликатов.  
    > **Плюсы и Минусы**: зависят от способа реализации

4.  **Понятие прозрачности  
    > **Свойство, из-за которого пользователям не видно распределение
    > (включая фрагментацию и репликацию) базы данных по множеству
    > узлов.  
    > Выделяют 4 вида прозрачности:  
    > - Прозрачность фрагментации  
    > - Прозрачность расположения фрагмента  
    > - Прозрачность количества реплик фрагмента  
    > - Прозрачность контроля доступа  
    > Иными словами, из-за наличия прозрачности, пользователь не видит
    > фрагменты, их расположение, кол-во реплик этих фрагментов (для них
    > видны сами таблицы данных) и для них кажется, что они имеют дело с
    > единым логическим образом базы данных и осуществляют доступ к
    > распределенным данным точно так же, как если бы они хранились
    > централизованно

#### 30. Двенадцать правил Дейта распределенных БД (821 страница Дейт). 

1.  **Локальная независимость.**  
    > Узлы в распределенной системе должны быть независимы, или
    > автономны. Локальная независимость означает, что все операции на
    > узле контролируются этим узлом.

2.  **Отсутствие зависимости от центрального узла.  
    > **Локальная независимость предполагает, что все узлы в
    > распределенной системе должны рассматриваться как равные. Поэтому,
    > в частности, не должно быть никаких обращений к центральному, или
    > главному, узлу для получения некоторой централизованной услуги.

3.  **Непрерывное функционирование.  
    > **Это качество можно трактовать как возможность непрерывного
    > доступа к данным вне зависимости от их расположения и вне
    > зависимости от операций, выполняемых на локальных узлах.

4.  **Независимость от расположения.  
    > **Это свойство означает полную прозрачность расположения данных.
    > Пользователь, обращающийся к распределенной БД, ничего не должен
    > знать о реальном, физическом размещении данных в узлах
    > информационной системы. Все операции над данными выполняются без
    > учета их местонахождения. Транспортировка запросов к базам данных
    > осуществляется встроенными системными средствами.

5.  **Независимость от фрагментации (прозрачность фрагментации).  
    > **Это свойство трактуется как возможность распределенного (то есть
    > на различных узлах) размещения данных, логически представляющих
    > собой единое целое.  
    > Существует фрагментация двух типов: горизонтальная и вертикальная.
    > Первая означает хранение строк одной таблицы на различных узлах
    > (фактически, хранение строк одной логической таблицы в нескольких
    > идентичных физических таблицах на различных узлах). Вторая
    > означает распределение столбцов логической таблицы по нескольким
    > узлам.

6.  **Независимость от репликации.  
    > Репликация** — одна из техник масштабирования баз данных. Состоит
    > эта техника в том, что данные с одного сервера базы данных
    > постоянно копируются (реплицируются) на один или несколько других
    > (называемые репликами).  
    > **  
    > **В системе поддерживается независимость от репликации, если
    > заданное хранимое отношение или заданный фрагмент могут быть
    > представлены несколькими различными копиями, или репликами,
    > хранимыми на нескольких различных узлах.  
    > Репликация полезна по двум причинам. Во-первых, достигается
    > большая производительность (приложения могут работать с локальными
    > копиями, не обмениваясь данными с удаленными узлами). Во-вторых,
    > обеспечивается большая доступность (реплицированный объект
    > остается доступным для обработки до тех пор, пока остается
    > доступна хотя бы одна его реплика).

7.  **Обработка распределенных запросов.  
    > **Это свойство трактуется как возможность выполнения операций
    > выборки над распределенной базой данных, сформулированных в рамках
    > обычного запроса на языке SQL. Другими словами, операцию выборки
    > из распределенной БД можно сформулировать с помощью тех же
    > языковых средств, что и операцию над локальной базой данных.

8.  **Управление распределенными транзакциями.  
    > **Это качество распределенной БД можно трактовать как возможность
    > выполнения операций обновления распределенной базы данных (INSERT,
    > UPDATE, DELETE), не разрушающего целостность и согласованность
    > данных.

9.  **Аппаратная независимость.  
    > **Это свойство означает, что в качестве узлов распределенной
    > системы могут выступать компьютеры любых моделей и производителей
    > – от мэйнфреймов до “персоналок”.

10. **Независимость от операционной системы.  
    > **Это качество вытекает из предыдущего и означает многообразие
    > операционных систем, управляющих узлами распределенной системы.

11. **Независимость от сети.  
    > **Если система имеет возможность поддерживать много принципиально
    > различных узлов, отличающихся оборудованием и операционными
    > системами, безусловно необходимо, чтобы она также поддерживала ряд
    > типов различных коммуникационных сетей.

12. **Независимость от типа СУБД.  
    > **Это качество означает, что в распределенной системе могут “мирно
    > сосуществовать” СУБД различных производителей и возможны операции
    > поиска и обновления в базах данных различных моделей и форматов.

#### 31. Предпосылки к появлению NoSQL баз данных. 

-   Увеличение объемов хранения данных

-   Взаимосвязанность данных

-   Слабоструктурированная информация

-   Изменение в архитектуре ИС

#### 32. Общие характеристики NoSQL баз данных. 

-   Отказ от использования языка SQL

-   Неструктурированные schemaless (нереляционные) данные

-   Использование операторов для представления данных

-   Слабые ACID свойства (ACID - Атомарность, Согласованность,
    > Изолированность, Стойкость )

#### 33. CAP теорема. Пример.

**Теорема CAP (известная также как теорема Брюера)** — эвристическое
утверждение о том, что в любой реализации распределенных вычислений
возможно обеспечить не более двух из трёх следующих свойств:

-   **Согласованность данных**
    > ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA)
    > consistency) — во всех вычислительных узлах в один момент времени
    > данные не противоречат друг другу;

-   **Доступность**
    > ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA)
    > availability) — любой запрос к распределенной системе завершается
    > корректным откликом, однако без гарантии, что ответы всех узлов
    > системы совпадают;

-   **Устойчивость к разделению**
    > ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA)
    > partition tolerance) — расщепление распределенной системы на
    > несколько изолированных секций не приводит к некорректности
    > отклика от каждой из секций.

#### 34. NoSQL решения: хранилища ключ-значение и документоориентированные БД. 

<img src="img\media\image20.png" style="width:6.27083in;height:4.625in" />

<img src="img\media\image13.png" style="width:6.27083in;height:1.14583in" />

#### 35. NoSQL решения: колоночные и графовые БД. 

-   Хранение всей таблицы, но с физическим расположением записей не
    > построчно,

<img src="img\media\image14.png" style="width:6.02083in;height:6.66667in" />

#### 36. База знаний. Определение, отличие от базы данных, замкнутые и открытые БЗ. 

**База знаний** - это совокупность единиц знаний, которые представляют
собой формализованное с помощью некоторого метода представления знаний
отражение объектов проблемной области и их взаимосвязей, действий над
объектами и, возможно, неопределенностей, с которыми эти действия
осуществляются.

**Типы(классы):**

-   Замкнутые (не будут меняться)

-   Открытые

Взято из Википедии:
([<u>https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0\_%D0%B7%D0%BD%D0%B0%D0%BD%D0%B8%D0%B9</u>](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0_%D0%B7%D0%BD%D0%B0%D0%BD%D0%B8%D0%B9))

Вместе с тем полноценные базы знаний (в отличие от обычной базы данных)
содержат в себе не только фактическую информацию, но и [<u>правила
вывода</u>](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%B0_%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0),
позволяющие делать [<u>автоматические
умозаключения</u>](https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%BE%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D1%82%D0%B2%D0%BE_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC)
об уже имеющихся или вновь вводимых фактах и тем самым производить
[<u>семантическую</u>](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D0%BD%D1%82%D0%B8%D0%BA%D0%B0)
(осмысленную) обработку информации.

#### 37. Логическая модель представления знаний. 

<img src="img\media\image7.png" style="width:6.27083in;height:5.77083in" />

#### 38. Сетевая модель представления знаний, семантическая сеть, онтология. 

<img src="img\media\image15.png" style="width:6.27083in;height:8.36111in" />

<img src="img\media\image21.png" style="width:6.27083in;height:3.94792in" />

#### 39. Фреймовая модель представления знаний. 

**Фрейм** - структура для описания стереотипной ситуации, состоящая из
характеристик этой ситуации(слотов) и их значений.

**Значения слота** могут константными или задаваться с помощью процедуры
вычисления значений.

**Виды процедур:**

-   Если добавлено, то…

-   Если удалено, то…

-   Если нужно, то…

**Фасет** - слот, принимающий множество значений.  
Фреймы образуют иерархию с наследованием слотов родителей.

#### 40. Продукционная модель представления знаний. 

**Продукционная модель знания** —
[модель](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C),
основанная на
[правилах](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0),
позволяет представить знание в виде предложений типа «Если (условие), то
(действие)».  
  
**Продукционная модель обладает недостатком** - при накоплении
достаточно большого числа (порядка нескольких сотен) продукций, они
начинают противоречить друг другу.  
<img src="img\media\image1.png" style="width:4.44674in;height:2.75521in" />
